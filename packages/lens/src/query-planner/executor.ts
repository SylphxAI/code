/**
 * Query Executor
 *
 * ARCHITECTURE:
 * - Executes query plans generated by optimizer
 * - Handles step dependencies and parallelization
 * - Merges results from multiple steps
 * - Integrates with DataLoader (Phase 3)
 */

import type { QueryContext } from '../resource/types.js';
import type { ExecutionPlan, QueryStep } from './optimizer.js';

/**
 * Step execution result
 */
export interface StepResult {
	/** Step index */
	stepIndex: number;

	/** Step that was executed */
	step: QueryStep;

	/** Raw data from database */
	data: any[];

	/** Execution time in milliseconds */
	executionTime: number;

	/** Number of rows returned */
	rowCount: number;
}

/**
 * Query execution result
 */
export interface ExecutionResult<T = any> {
	/** Final merged data */
	data: T[];

	/** All step results */
	steps: StepResult[];

	/** Total execution time */
	totalTime: number;

	/** Total database queries executed */
	queryCount: number;

	/** Execution plan used */
	plan: ExecutionPlan;
}

/**
 * Execute a query plan
 *
 * @example
 * ```typescript
 * const result = await executeQuery(plan, context);
 * console.log(result.data); // Final merged data
 * console.log(result.totalTime); // Execution time
 * console.log(result.queryCount); // Number of queries
 * ```
 */
export async function executeQuery<T = any>(
	plan: ExecutionPlan,
	context: QueryContext
): Promise<ExecutionResult<T>> {
	const startTime = Date.now();
	const stepResults: StepResult[] = [];
	const stepDataCache = new Map<number, any[]>();

	// Execute steps in order, respecting dependencies
	for (let i = 0; i < plan.steps.length; i++) {
		const step = plan.steps[i];

		// Wait for dependencies to complete
		const dependencyData = await waitForDependencies(
			step.dependencies,
			stepDataCache
		);

		// Execute this step
		const result = await executeStep(step, context, dependencyData);
		stepResults.push(result);

		// Cache result for dependent steps
		stepDataCache.set(i, result.data);
	}

	// Merge all results
	const data = await mergeResults<T>(plan, stepResults, stepDataCache);

	const totalTime = Date.now() - startTime;

	return {
		data,
		steps: stepResults,
		totalTime,
		queryCount: stepResults.length,
		plan,
	};
}

/**
 * Wait for dependency steps to complete
 */
async function waitForDependencies(
	dependencies: number[],
	cache: Map<number, any[]>
): Promise<Map<number, any[]>> {
	const dependencyData = new Map<number, any[]>();

	for (const depIndex of dependencies) {
		const data = cache.get(depIndex);
		if (data) {
			dependencyData.set(depIndex, data);
		}
	}

	return dependencyData;
}

/**
 * Execute a single query step
 */
async function executeStep(
	step: QueryStep,
	context: QueryContext,
	dependencyData: Map<number, any[]>
): Promise<StepResult> {
	const startTime = Date.now();

	// Execute based on step type and strategy
	let data: any[] = [];

	if (step.type === 'root') {
		// Root query - fetch from database
		data = await executeRootQuery(step, context);
	} else if (step.type === 'relationship') {
		// Relationship query - use parent data to build query
		data = await executeRelationshipQuery(step, context, dependencyData);
	}

	const executionTime = Date.now() - startTime;

	return {
		stepIndex: -1, // Will be set by caller
		step,
		data,
		executionTime,
		rowCount: data.length,
	};
}

/**
 * Execute root query
 * Fetches base resource data
 */
async function executeRootQuery(
	step: QueryStep,
	context: QueryContext
): Promise<any[]> {
	// Use loader to fetch root data
	// Note: For list queries, we'd need to add a findMany method
	// For now, this demonstrates the integration pattern

	console.warn(
		`[Executor] Root query for ${step.resource} - Full DB integration pending`
	);

	// In full implementation:
	// return await context.db.query[step.resource].findMany({
	//   select: buildSelectObject(step.fields)
	// });

	return [];
}

/**
 * Execute relationship query
 * Fetches related data based on parent results
 */
async function executeRelationshipQuery(
	step: QueryStep,
	context: QueryContext,
	dependencyData: Map<number, any[]>
): Promise<any[]> {
	// Get parent data from dependencies
	const parentData = dependencyData.get(step.dependencies[0]);
	if (!parentData || parentData.length === 0) {
		return [];
	}

	// Extract parent IDs
	const parentIds = parentData.map((p) => p.id).filter(Boolean);
	if (parentIds.length === 0) {
		return [];
	}

	// Use loader to fetch related data (automatically batched)
	// loadByField will batch this with other relationship queries in same tick
	console.warn(
		`[Executor] Relationship query for ${step.resource}.${step.relationship} - Using loader (DB integration pending)`
	);

	// In full implementation:
	// const grouped = await context.loader.loadByField(
	//   step.resource,
	//   foreignKey,  // Need to get from relationship definition
	//   parentIds
	// );
	// return Array.from(grouped.values()).flat();

	return [];
}

/**
 * Merge step results into final data structure
 * Reconstructs nested object graph from flat query results
 */
async function mergeResults<T>(
	plan: ExecutionPlan,
	stepResults: StepResult[],
	stepDataCache: Map<number, any[]>
): Promise<T[]> {
	// Get root data
	const rootResult = stepResults[0];
	if (!rootResult) {
		return [];
	}

	const rootData = rootResult.data;

	// If no relationships, return root data as-is
	if (plan.steps.length === 1) {
		return rootData as T[];
	}

	// Merge relationship data into root data
	// PLACEHOLDER: Full implementation in Phase 3 with DataLoader
	// This requires mapping foreign keys and building nested structures

	console.warn('[Executor] Result merging - Full implementation pending (Phase 3)');

	return rootData as T[];
}

/**
 * Execute steps in parallel when possible
 * Groups parallelizable steps and executes concurrently
 */
export async function executeQueryParallel<T = any>(
	plan: ExecutionPlan,
	context: QueryContext
): Promise<ExecutionResult<T>> {
	const startTime = Date.now();
	const stepResults: StepResult[] = new Array(plan.steps.length);
	const stepDataCache = new Map<number, any[]>();

	// Group steps by dependency level
	const levels = groupStepsByLevel(plan.steps);

	// Execute each level in sequence, but steps within level in parallel
	for (const level of levels) {
		const promises = level.map(async (stepIndex) => {
			const step = plan.steps[stepIndex];

			// Wait for dependencies
			const dependencyData = await waitForDependencies(
				step.dependencies,
				stepDataCache
			);

			// Execute step
			const result = await executeStep(step, context, dependencyData);
			result.stepIndex = stepIndex;

			return { stepIndex, result };
		});

		// Wait for all steps in this level
		const results = await Promise.all(promises);

		// Cache results
		for (const { stepIndex, result } of results) {
			stepResults[stepIndex] = result;
			stepDataCache.set(stepIndex, result.data);
		}
	}

	// Merge results
	const data = await mergeResults<T>(plan, stepResults, stepDataCache);

	const totalTime = Date.now() - startTime;

	return {
		data,
		steps: stepResults,
		totalTime,
		queryCount: stepResults.length,
		plan,
	};
}

/**
 * Group steps by dependency level
 * Steps with same dependency depth can be executed in parallel
 */
function groupStepsByLevel(steps: QueryStep[]): number[][] {
	const levels: number[][] = [];
	const stepLevels = new Map<number, number>();

	// Calculate level for each step
	for (let i = 0; i < steps.length; i++) {
		const step = steps[i];

		if (step.dependencies.length === 0) {
			// No dependencies = level 0
			stepLevels.set(i, 0);
		} else {
			// Level = max(dependency levels) + 1
			const maxDepLevel = Math.max(
				...step.dependencies.map((depIdx) => stepLevels.get(depIdx) || 0)
			);
			stepLevels.set(i, maxDepLevel + 1);
		}
	}

	// Group by level
	for (const [stepIndex, level] of stepLevels.entries()) {
		if (!levels[level]) {
			levels[level] = [];
		}
		levels[level].push(stepIndex);
	}

	return levels;
}

/**
 * Get execution statistics from result
 */
export function getExecutionStats(result: ExecutionResult): {
	avgStepTime: number;
	slowestStep: StepResult | null;
	fastestStep: StepResult | null;
	totalRows: number;
	efficiency: number; // Rows per query
} {
	if (result.steps.length === 0) {
		return {
			avgStepTime: 0,
			slowestStep: null,
			fastestStep: null,
			totalRows: 0,
			efficiency: 0,
		};
	}

	const avgStepTime =
		result.steps.reduce((sum, step) => sum + step.executionTime, 0) /
		result.steps.length;

	const slowestStep = result.steps.reduce((slowest, step) =>
		step.executionTime > slowest.executionTime ? step : slowest
	);

	const fastestStep = result.steps.reduce((fastest, step) =>
		step.executionTime < fastest.executionTime ? step : fastest
	);

	const totalRows = result.steps.reduce((sum, step) => sum + step.rowCount, 0);

	const efficiency = totalRows / result.queryCount;

	return {
		avgStepTime,
		slowestStep,
		fastestStep,
		totalRows,
		efficiency,
	};
}
